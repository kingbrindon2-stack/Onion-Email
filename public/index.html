<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é£ä¹¦-æ»´æ»´å…¥èŒä¸­å¿ƒ</title>
  <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/element-plus"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f7fa; }
    .app-container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 24px; border-radius: 12px; margin-bottom: 20px; }
    .header h1 { font-size: 24px; font-weight: 600; }
    .header p { opacity: 0.9; margin-top: 4px; }
    .main-card { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 12px rgba(0,0,0,0.08); }
    .filters-row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-end; margin-bottom: 20px; }
    .filter-item { flex: 1; min-width: 180px; }
    .filter-item label { display: block; font-size: 13px; color: #606266; margin-bottom: 6px; font-weight: 500; }
    .table-toolbar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid #ebeef5; }
    .toolbar-left { display: flex; align-items: center; gap: 16px; }
    .toolbar-right { display: flex; gap: 12px; }
    .stats { display: flex; gap: 16px; }
    .stat-item { background: #f4f4f5; padding: 6px 12px; border-radius: 6px; font-size: 13px; }
    .stat-item strong { color: #409eff; }
    .user-info { display: flex; flex-direction: column; gap: 2px; }
    .user-name { font-weight: 600; color: #303133; }
    .user-meta { font-size: 12px; color: #909399; }
    .editable-input { width: 100%; }
    .action-btn { padding: 4px 8px; }
    .log-console { background: #1e1e1e; border-radius: 12px; padding: 16px; margin-top: 20px; height: 200px; overflow-y: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; }
    .log-console-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .log-console-header h3 { color: #4ade80; font-size: 14px; }
    .log-entry { padding: 3px 0; }
    .log-time { color: #6b7280; margin-right: 8px; }
    .log-level { padding: 1px 5px; border-radius: 3px; font-size: 10px; text-transform: uppercase; margin-right: 8px; }
    .log-level.info { background: #3b82f6; color: white; }
    .log-level.success { background: #22c55e; color: white; }
    .log-level.warn { background: #f59e0b; color: white; }
    .log-level.error { background: #ef4444; color: white; }
    .log-message { color: #e5e7eb; }
    .el-table .cell { padding: 8px 12px; }
    .tab-desc { font-size: 13px; color: #909399; margin-bottom: 16px; }
  </style>
</head>
<body>
  <div id="app">
    <div class="app-container">
      <!-- Header -->
      <div class="header">
        <h1>ğŸš€ é£ä¹¦-æ»´æ»´å…¥èŒä¸­å¿ƒ</h1>
        <p>è‡ªåŠ¨åŒ–å·¥ä½œé‚®ä»¶å’Œä¼ä¸šæ»´æ»´è´¦å·é…ç½®</p>
      </div>

      <!-- Main Content -->
      <div class="main-card">
        <el-tabs v-model="activeTab" @tab-change="handleTabChange">
          <!-- Tab 1: å¼€é€šé‚®ç®± -->
          <el-tab-pane label="ğŸ“§ å¼€é€šé‚®ç®±" name="email">
            <p class="tab-desc">ä¸ºå¾…å…¥èŒå‘˜å·¥ï¼ˆpreboardingï¼‰é…ç½®å·¥ä½œé‚®ç®±</p>
            
            <!-- Filters -->
            <div class="filters-row">
              <div class="filter-item">
                <label>åŸå¸‚</label>
                <el-select v-model="emailFilters.city" placeholder="å…¨éƒ¨åŸå¸‚" clearable style="width: 100%">
                  <el-option v-for="city in emailCities" :key="city" :label="city" :value="city" />
                </el-select>
              </div>
              <div class="filter-item">
                <label>å…¥èŒæ—¥æœŸ</label>
                <el-date-picker v-model="emailFilters.date" type="date" placeholder="é€‰æ‹©æ—¥æœŸ" 
                  value-format="YYYY-MM-DD" style="width: 100%" clearable />
              </div>
              <div class="filter-item" style="flex: 0;">
                <label>&nbsp;</label>
                <el-button type="primary" @click="fetchEmailHires" :loading="emailLoading">
                  åˆ·æ–°
                </el-button>
              </div>
            </div>

            <!-- Toolbar -->
            <div class="table-toolbar">
              <div class="toolbar-left">
                <el-checkbox v-model="emailSelectAll" @change="handleEmailSelectAll">å…¨é€‰</el-checkbox>
                <div class="stats">
                  <span class="stat-item">æ€»è®¡: <strong>{{ filteredEmailHires.length }}</strong></span>
                  <span class="stat-item">å·²é€‰: <strong>{{ selectedEmailUsers.length }}</strong></span>
                </div>
              </div>
              <div class="toolbar-right">
                <el-button type="success" @click="batchProvisionEmail" 
                  :disabled="selectedEmailUsers.length === 0" :loading="emailProvisioning">
                  ä¸€é”®å¼€é€šé‚®ç®± ({{ selectedEmailUsers.length }})
                </el-button>
              </div>
            </div>

            <!-- Table -->
            <el-table :data="filteredEmailHires" v-loading="emailLoading" stripe row-key="id" style="width: 100%">
              <el-table-column width="50">
                <template #default="{ row }">
                  <el-checkbox v-model="row.selected" />
                </template>
              </el-table-column>
              
              <el-table-column label="å‘˜å·¥ä¿¡æ¯" min-width="200">
                <template #default="{ row }">
                  <div class="user-info">
                    <span class="user-name">{{ row.name }}</span>
                    <span class="user-meta">{{ row.city }} Â· ğŸ“… {{ row.onboardingDate }}</span>
                  </div>
                </template>
              </el-table-column>

              <el-table-column label="ç”µè¯" width="140">
                <template #default="{ row }">
                  <el-input v-model="row.phone" size="small" />
                </template>
              </el-table-column>

              <el-table-column label="é‚®ç®±" min-width="250">
                <template #default="{ row }">
                  <el-input v-model="row.suggested_email" size="small" />
                </template>
              </el-table-column>

              <el-table-column label="æ“ä½œ" width="100" fixed="right">
                <template #default="{ row }">
                  <el-button type="primary" size="small" @click="provisionSingleEmail(row)" 
                    :loading="row.provisioning">
                    å¼€é€š
                  </el-button>
                </template>
              </el-table-column>
            </el-table>
          </el-tab-pane>

          <!-- Tab 2: å¼€é€šæ»´æ»´ -->
          <el-tab-pane label="ğŸš— å¼€é€šæ»´æ»´" name="didi">
            <p class="tab-desc">ä¸ºå·²å…¥èŒå‘˜å·¥ï¼ˆcompletedï¼‰å¼€é€šä¼ä¸šæ»´æ»´è´¦å·</p>
            
            <!-- Filters -->
            <div class="filters-row">
              <div class="filter-item">
                <label>åŸå¸‚</label>
                <el-select v-model="didiFilters.city" placeholder="å…¨éƒ¨åŸå¸‚" clearable style="width: 100%">
                  <el-option v-for="city in didiCities" :key="city" :label="city" :value="city" />
                </el-select>
              </div>
              <div class="filter-item">
                <label>å…¥èŒæ—¥æœŸ</label>
                <el-date-picker v-model="didiFilters.date" type="date" placeholder="é€‰æ‹©æ—¥æœŸ" 
                  value-format="YYYY-MM-DD" style="width: 100%" clearable />
              </div>
              <div class="filter-item" style="flex: 0;">
                <label>&nbsp;</label>
                <el-button type="primary" @click="fetchDidiHires" :loading="didiLoading">
                  åˆ·æ–°
                </el-button>
              </div>
            </div>

            <!-- Toolbar -->
            <div class="table-toolbar">
              <div class="toolbar-left">
                <el-checkbox v-model="didiSelectAll" @change="handleDidiSelectAll">å…¨é€‰</el-checkbox>
                <div class="stats">
                  <span class="stat-item">æ€»è®¡: <strong>{{ filteredDidiHires.length }}</strong></span>
                  <span class="stat-item">å·²é€‰: <strong>{{ selectedDidiUsers.length }}</strong></span>
                </div>
              </div>
              <div class="toolbar-right">
                <el-button type="success" @click="batchProvisionDidi" 
                  :disabled="selectedDidiUsers.length === 0" :loading="didiProvisioning">
                  ä¸€é”®å¼€é€šæ»´æ»´ ({{ selectedDidiUsers.length }})
                </el-button>
              </div>
            </div>

            <!-- Table -->
            <el-table :data="filteredDidiHires" v-loading="didiLoading" stripe row-key="id" style="width: 100%">
              <el-table-column width="50">
                <template #default="{ row }">
                  <el-checkbox v-model="row.selected" />
                </template>
              </el-table-column>
              
              <el-table-column label="å‘˜å·¥ä¿¡æ¯" min-width="200">
                <template #default="{ row }">
                  <div class="user-info">
                    <span class="user-name">{{ row.name }}</span>
                    <span class="user-meta">{{ row.city }} Â· ğŸ“… {{ row.onboardingDate }}</span>
                  </div>
                </template>
              </el-table-column>

              <el-table-column label="ç”µè¯" width="140">
                <template #default="{ row }">
                  <el-input v-model="row.phone" size="small" />
                </template>
              </el-table-column>

              <el-table-column label="æ»´æ»´è§„åˆ™" min-width="200">
                <template #default="{ row }">
                  <el-select v-model="row.suggested_didi_rule_id" size="small" style="width: 100%" 
                    placeholder="é€‰æ‹©è§„åˆ™" filterable>
                    <el-option v-for="rule in didiRules" :key="rule.id" 
                      :label="rule.name" :value="rule.id" />
                  </el-select>
                </template>
              </el-table-column>

              <el-table-column label="æ“ä½œ" width="100" fixed="right">
                <template #default="{ row }">
                  <el-button type="primary" size="small" @click="provisionSingleDidi(row)" 
                    :loading="row.provisioning">
                    å¼€é€š
                  </el-button>
                </template>
              </el-table-column>
            </el-table>
          </el-tab-pane>
        </el-tabs>
      </div>

      <!-- Log Console -->
      <div class="log-console">
        <div class="log-console-header">
          <h3>ğŸ“Ÿ å®æ—¶æ—¥å¿—</h3>
          <el-button size="small" text @click="clearLogs" style="color: #6b7280;">æ¸…ç©º</el-button>
        </div>
        <div v-for="(log, index) in logs" :key="index" class="log-entry">
          <span class="log-time">{{ formatTime(log.timestamp) }}</span>
          <span :class="['log-level', log.level]">{{ log.level }}</span>
          <span class="log-message">{{ log.message }}</span>
        </div>
        <div v-if="logs.length === 0" style="color: #6b7280; text-align: center; padding: 40px;">
          ç­‰å¾…æ—¥å¿—...
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, computed, onMounted, onUnmounted, watch } = Vue;
    const { ElMessage, ElMessageBox } = ElementPlus;

    createApp({
      setup() {
        const activeTab = ref('email');
        const logs = ref([]);
        let eventSource = null;

        // Email Tab State
        const emailLoading = ref(false);
        const emailProvisioning = ref(false);
        const emailHires = ref([]);
        const emailFilters = ref({ city: '', date: '' });
        const emailSelectAll = ref(false);

        // Didi Tab State
        const didiLoading = ref(false);
        const didiProvisioning = ref(false);
        const didiHires = ref([]);
        const didiFilters = ref({ city: '', date: '' });
        const didiSelectAll = ref(false);
        const didiRules = ref([]);

        // Computed
        const emailCities = computed(() => {
          const citySet = new Set(emailHires.value.map(h => h.city).filter(Boolean));
          return Array.from(citySet).sort();
        });

        const filteredEmailHires = computed(() => {
          return emailHires.value.filter(h => {
            if (emailFilters.value.city && h.city !== emailFilters.value.city) return false;
            if (emailFilters.value.date && h.onboardingDate !== emailFilters.value.date) return false;
            return true;
          });
        });

        const selectedEmailUsers = computed(() => {
          return filteredEmailHires.value.filter(h => h.selected);
        });

        const didiCities = computed(() => {
          const citySet = new Set(didiHires.value.map(h => h.city).filter(Boolean));
          return Array.from(citySet).sort();
        });

        const filteredDidiHires = computed(() => {
          return didiHires.value.filter(h => {
            if (didiFilters.value.city && h.city !== didiFilters.value.city) return false;
            if (didiFilters.value.date && h.onboardingDate !== didiFilters.value.date) return false;
            return true;
          });
        });

        const selectedDidiUsers = computed(() => {
          return filteredDidiHires.value.filter(h => h.selected);
        });

        // Methods
        const fetchEmailHires = async () => {
          emailLoading.value = true;
          try {
            const res = await fetch('/api/hires?status=preboarding');
            const data = await res.json();
            if (data.success) {
              emailHires.value = data.data.map(h => ({ ...h, selected: false, provisioning: false }));
            } else {
              ElMessage.error(data.error || 'è·å–æ•°æ®å¤±è´¥');
            }
          } catch (err) {
            ElMessage.error('ç½‘ç»œé”™è¯¯: ' + err.message);
          } finally {
            emailLoading.value = false;
          }
        };

        const fetchDidiHires = async () => {
          didiLoading.value = true;
          try {
            const res = await fetch('/api/hires?status=completed');
            const data = await res.json();
            if (data.success) {
              didiHires.value = data.data.map(h => ({ ...h, selected: false, provisioning: false }));
            } else {
              ElMessage.error(data.error || 'è·å–æ•°æ®å¤±è´¥');
            }
          } catch (err) {
            ElMessage.error('ç½‘ç»œé”™è¯¯: ' + err.message);
          } finally {
            didiLoading.value = false;
          }
        };

        const fetchDidiRules = async () => {
          try {
            const res = await fetch('/api/didi/rules');
            const data = await res.json();
            if (data.success) {
              didiRules.value = data.data;
            }
          } catch (err) {
            console.error('Failed to fetch Didi rules:', err);
          }
        };

        const handleEmailSelectAll = (val) => {
          filteredEmailHires.value.forEach(h => h.selected = val);
        };

        const handleDidiSelectAll = (val) => {
          filteredDidiHires.value.forEach(h => h.selected = val);
        };

        const provisionSingleEmail = async (row) => {
          row.provisioning = true;
          try {
            const res = await fetch('/api/provision/email', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id: row.id, email: row.suggested_email })
            });
            const data = await res.json();
            if (data.success) {
              ElMessage.success(`${row.name} é‚®ç®±å¼€é€šæˆåŠŸ`);
            } else {
              ElMessage.error(data.error || 'å¼€é€šå¤±è´¥');
            }
          } catch (err) {
            ElMessage.error('ç½‘ç»œé”™è¯¯: ' + err.message);
          } finally {
            row.provisioning = false;
          }
        };

        const batchProvisionEmail = async () => {
          const users = selectedEmailUsers.value;
          if (users.length === 0) return;

          try {
            await ElMessageBox.confirm(`ç¡®å®šä¸º ${users.length} åå‘˜å·¥å¼€é€šé‚®ç®±ï¼Ÿ`, 'ç¡®è®¤æ“ä½œ', {
              confirmButtonText: 'ç¡®å®š',
              cancelButtonText: 'å–æ¶ˆ',
              type: 'warning'
            });
          } catch { return; }

          emailProvisioning.value = true;
          try {
            const res = await fetch('/api/provision/email/batch', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                users: users.map(u => ({ id: u.id, email: u.suggested_email, name: u.name }))
              })
            });
            const data = await res.json();
            if (data.success) {
              ElMessage.success(`æˆåŠŸå¼€é€š ${data.summary?.successful || 0} ä¸ªé‚®ç®±`);
              users.forEach(u => u.selected = false);
            } else {
              ElMessage.error(data.error || 'æ‰¹é‡å¼€é€šå¤±è´¥');
            }
          } catch (err) {
            ElMessage.error('ç½‘ç»œé”™è¯¯: ' + err.message);
          } finally {
            emailProvisioning.value = false;
          }
        };

        const provisionSingleDidi = async (row) => {
          if (!row.suggested_didi_rule_id) {
            ElMessage.warning('è¯·å…ˆé€‰æ‹©æ»´æ»´è§„åˆ™');
            return;
          }
          row.provisioning = true;
          try {
            const res = await fetch('/api/provision/didi', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name: row.name,
                phone: row.phone,
                didi_rule_id: row.suggested_didi_rule_id
              })
            });
            const data = await res.json();
            if (data.success) {
              ElMessage.success(`${row.name} æ»´æ»´è´¦å·å¼€é€šæˆåŠŸ`);
            } else {
              ElMessage.error(data.error || 'å¼€é€šå¤±è´¥');
            }
          } catch (err) {
            ElMessage.error('ç½‘ç»œé”™è¯¯: ' + err.message);
          } finally {
            row.provisioning = false;
          }
        };

        const batchProvisionDidi = async () => {
          const users = selectedDidiUsers.value;
          if (users.length === 0) return;

          const noRule = users.filter(u => !u.suggested_didi_rule_id);
          if (noRule.length > 0) {
            ElMessage.warning(`${noRule.length} åå‘˜å·¥æœªé€‰æ‹©æ»´æ»´è§„åˆ™`);
            return;
          }

          try {
            await ElMessageBox.confirm(`ç¡®å®šä¸º ${users.length} åå‘˜å·¥å¼€é€šæ»´æ»´ï¼Ÿ`, 'ç¡®è®¤æ“ä½œ', {
              confirmButtonText: 'ç¡®å®š',
              cancelButtonText: 'å–æ¶ˆ',
              type: 'warning'
            });
          } catch { return; }

          didiProvisioning.value = true;
          try {
            const res = await fetch('/api/provision/didi/batch', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                users: users.map(u => ({
                  name: u.name,
                  phone: u.phone,
                  didi_rule_id: u.suggested_didi_rule_id
                }))
              })
            });
            const data = await res.json();
            if (data.success) {
              ElMessage.success(`æˆåŠŸå¼€é€š ${data.summary?.successful || 0} ä¸ªæ»´æ»´è´¦å·`);
              users.forEach(u => u.selected = false);
            } else {
              ElMessage.error(data.error || 'æ‰¹é‡å¼€é€šå¤±è´¥');
            }
          } catch (err) {
            ElMessage.error('ç½‘ç»œé”™è¯¯: ' + err.message);
          } finally {
            didiProvisioning.value = false;
          }
        };

        const handleTabChange = (tab) => {
          if (tab === 'email' && emailHires.value.length === 0) {
            fetchEmailHires();
          } else if (tab === 'didi' && didiHires.value.length === 0) {
            fetchDidiHires();
            fetchDidiRules();
          }
        };

        const connectSSE = () => {
          eventSource = new EventSource('/api/logs/stream');
          eventSource.onmessage = (event) => {
            try {
              const log = JSON.parse(event.data);
              logs.value.push(log);
              if (logs.value.length > 200) logs.value.shift();
            } catch {}
          };
          eventSource.onerror = () => {
            setTimeout(connectSSE, 3000);
          };
        };

        const formatTime = (timestamp) => {
          const d = new Date(timestamp);
          return d.toLocaleTimeString('zh-CN', { hour12: false });
        };

        const clearLogs = () => {
          logs.value = [];
        };

        // Watch for select all sync
        watch(selectedEmailUsers, (val) => {
          emailSelectAll.value = val.length === filteredEmailHires.value.length && val.length > 0;
        });

        watch(selectedDidiUsers, (val) => {
          didiSelectAll.value = val.length === filteredDidiHires.value.length && val.length > 0;
        });

        onMounted(() => {
          fetchEmailHires();
          connectSSE();
        });

        onUnmounted(() => {
          if (eventSource) eventSource.close();
        });

        return {
          activeTab, logs,
          emailLoading, emailProvisioning, emailHires, emailFilters, emailSelectAll,
          didiLoading, didiProvisioning, didiHires, didiFilters, didiSelectAll, didiRules,
          emailCities, filteredEmailHires, selectedEmailUsers,
          didiCities, filteredDidiHires, selectedDidiUsers,
          fetchEmailHires, fetchDidiHires, handleTabChange,
          handleEmailSelectAll, handleDidiSelectAll,
          provisionSingleEmail, batchProvisionEmail,
          provisionSingleDidi, batchProvisionDidi,
          formatTime, clearLogs
        };
      }
    }).use(ElementPlus).mount('#app');
  </script>
</body>
</html>
